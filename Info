1. Аннотация @ModelAttribute(<какое то название ключа>) для аннотирования метода:

- В модель в каждом методе текущего контроллера добавляет пару ключ-значение
- Используется для добавления тех пар ключ-значения, которые нужны во всех моделях этого контроллера
- Любая модель из этого контроллера по умолчанию будет иметь значение с ключом который мы указываем в аргумент метода
- Мы можем добавлять не только строки, но и объекты

Пример: тут любая модель из этого контроллера по умолчанию будет иметь значение с ключом messageObject
@ModelAttribute("messageObject")
public MessageObject populateHeaderMessage() {
    MessageObject messageObject = new MessageObject();
    messageObject.setSomeField("Hello!");

    return messageObject;
}

2. Аннотация @PathVariable(для полей метода): в аргумент указывается в "" то, что бы хотим считать с url и присваиваем Java типу и переменной

Пример:
@GetMapping("/{id}/edit")
public String edit(Model model, @PathVariable("id") int id) {
    // и тут мы считываем id, и присвоили int id
}


Связь Java приложения с БД:
 - Jdbc API - самый низкоуровневый(делаем всё вручную) - сделали
 - JdbcTemplate - тонкая обёртка вокруг Jdbc API. Часть Spring Framework(Берёт часть дел на себя) - сделали
 - Hibernate - Самый высокий уровень абстракции. Автоматически переводит Java объекты в строки таблицы и наоборот. Может автоматом создавать таблицы в БД(это называется ORM)

DDL команды - команды, где работаем именно с самой СУБД(CREATE, DROP и т.д.)
DML команды - команды, где работаем с самими данными этой СУБД(SELECT, UPDATE, DELETE(столбов/строк))

PreparedStatement работает быстрее чем обычный Statement.
 - PreparedStatement - SQL запрос компилируется только один раз
 - Statement - SQL запрос компилируется каждый раз

PreparedStatement - один раз скомпилировал, перевёл в машинный код и затем он в этот машинный код вставляет значения, которые мы задали(в полях)

RowMapper - отображает строки из таблицы в нашей сущности(в нашем случае Person)

RowMapper мы указываем в запросах: jdbcTemplate.query
* return jdbcTemplate.query("SELECT * FROM Person", new BeanPropertyRowMapper<>(Person.class));

А когда мы делаем jdbcTemplate.update(...) то RowMapper мы не используем
* jdbcTemplate.update("INSERT INTO Person VALUES(1, ?, ?, ?)", person.getName(), person.getAge(),
                 person.getEmail());

@PropertySource() - указываем, путь до файла с ресурсами

Batch Update(пакетное обновление) - если у нас множество запросов к БД, то Batch Update соберёт всё в кучу и сделает один запрос к БД, и распараллелит операции

СУБД:
1. Автоматичекая генерация id:
SERIAL - задаёт свою последовательность id(старый вариант)
* create table Person (
    id SERIAL,
    name varchar,
    age int,
    email varchar
);

Обновлённый вариант:
Вместо SERIAL используем:
id INT GENERATED BY DEFAULT AS IDENTITY