1. Аннотация @ModelAttribute(<какое то название ключа>) для аннотирования метода:

- В модель в каждом методе текущего контроллера добавляет пару ключ-значение
- Используется для добавления тех пар ключ-значения, которые нужны во всех моделях этого контроллера
- Любая модель из этого контроллера по умолчанию будет иметь значение с ключом который мы указываем в аргумент метода
- Мы можем добавлять не только строки, но и объекты

Пример: тут любая модель из этого контроллера по умолчанию будет иметь значение с ключом messageObject
@ModelAttribute("messageObject")
public MessageObject populateHeaderMessage() {
    MessageObject messageObject = new MessageObject();
    messageObject.setSomeField("Hello!");

    return messageObject;
}

2. Аннотация @PathVariable(для полей метода): в аргумент указывается в "" то, что бы хотим считать с url и присваиваем Java типу и переменной

Пример:
@GetMapping("/{id}/edit")
public String edit(Model model, @PathVariable("id") int id) {
    // и тут мы считываем id, и присвоили int id
}


Связь Java приложения с БД:
 - Jdbc API - самый низкоуровневый(делаем всё вручную) - сделали
 - JdbcTemplate - тонкая обёртка вокруг Jdbc API. Часть Spring Framework(Берёт часть дел на себя) - сделали
 - Hibernate - Самый высокий уровень абстракции. Автоматически переводит Java объекты в строки таблицы и наоборот. Может автоматом создавать таблицы в БД(это называется ORM)

DDL команды - команды, где работаем именно с самой СУБД(CREATE, DROP и т.д.)
DML команды - команды, где работаем с самими данными этой СУБД(SELECT, UPDATE, DELETE(столбов/строк))

PreparedStatement работает быстрее чем обычный Statement.
 - PreparedStatement - SQL запрос компилируется только один раз
 - Statement - SQL запрос компилируется каждый раз

PreparedStatement - один раз скомпилировал, перевёл в машинный код и затем он в этот машинный код вставляет значения, которые мы задали(в полях)

RowMapper - отображает строки из таблицы в нашей сущности(в нашем случае Person)

RowMapper мы указываем в запросах: jdbcTemplate.query
* return jdbcTemplate.query("SELECT * FROM Person", new BeanPropertyRowMapper<>(Person.class));

А когда мы делаем jdbcTemplate.update(...) то RowMapper мы не используем
* jdbcTemplate.update("INSERT INTO Person VALUES(1, ?, ?, ?)", person.getName(), person.getAge(),
                 person.getEmail());

@PropertySource() - указываем, путь до файла с ресурсами

Batch Update(пакетное обновление) - если у нас множество запросов к БД, то Batch Update соберёт всё в кучу и сделает один запрос к БД, и распараллелит операции

СУБД:
1. Автоматичекая генерация id:
SERIAL - задаёт свою последовательность id(старый вариант)
* create table Person (
    id SERIAL,
    name varchar,
    age int,
    email varchar
);

Обновлённый вариант:
Вместо SERIAL используем:
id int GENERATED BY DEFAULT AS IDENTITY


2. Ограничения(самые популярные):
 - NOT NULL
 - UNIQUE(уникальные значения)
 - PRIMARY KEY(первичный ключ(UNIQUE + NOT NULL))
 - FOREIGN KEY(внешний ключ)
 - CHECK(указываем ограничения на значения(*age > 0))


3. Отношения связи в БД:
 - Один ко многим(покупатель и заказы, учитель и ученики, библиотека и книги, режиссёр и его фильмы)
 - Один к одному(гражданин и паспорт страны, президент и страна, директор и школа)
 - Многие ко многим(актёры и их фильмы(в нескольких фильмах снимается сразу несколько актёров), студенты и их занятия)


4. JOIN:
 - Join(Inner Join) - ЧАСТО ИСПОЛЬЗУЕМЫЙ - будет строгое условие, и будет выборка пересечений строк по удовлетворению условий
 - Outer Join:
    - Left Join - ЧАСТО ИСПОЛЬЗУЕМЫЙ - будет выборка всех строк из таблица А в выборке не всех строк из таблицы В
    - Right Join) - тоже самое что и Left Join, можно заменить поменяв таблицы местами
 - Cross Join - каждая строка из таблица А ставится в пару с каждой строкой из таблица B


5. REFERENCES - указывает на внешний ключ:
* create Movie(
    movie_id int,
    director_id int not null references Director(director_id)
  )


6. Индексы в Postgresql:
 - Нужны для того, что бы создавать их на какие то колонки, где будет делать часто по ним выборку(через WHERE) для БЫСТРОТЫ
 - Работают намного быстрее чем линейный поиск:
    - Линейный поиск - в худшем случае будет столько итераций сколько и строчек в столбце
    - Двоичный поиск - log2(всегда будет отделять половину выборки)
    - Если мы понимаем, что будут вставки в таблицу, то лучше не делать индексацию на столбец, т.к. это будет занимать очень много времени

Типы индексов:
- PRIMARY KEY
- B-Tree Index
- Hash Index
- Gin & Gist Index
- BRIN Index

Создание индексов на столбец в таблице:
CREATE INDEX ON <название таблицы> (<название столбца>) USING <тип индексов>


7. Каскадирование:
Если мы удалим какие-то значения, на которые ссылаются какие-либо значения, то у нас будет ошибка, и тут приходить КАСКАДИРОВАНИЕ на помощь.
  - CASCADE - удаляет строки в зависимой таблице и удаляются все связанные с ним значения
  - SET NULL - выставляет внешние значения null
  - RESTRICT - поведение по умолчанию, выдаст ошибку если мы удалим что-то
СИНАКСИС:
user_id int REFERENCES Person(user_id) ON DELETE <CASCADE/SET NULL/RESTRICT>


.isPresent() - метод который проверяет на сущестование(у класса Optional; лучше использовать его чем делать проверку на null)

C помощью тега <select> and <option> мы можем создать ВЫПАДАЮЩИЕ СПИСКИ.
